to-do

- CALCULATION OF MOVES FOR TRANCHES NEEDS TO BE DONE DIFFERENTLY. NOT REWRITING THE LIST
	(OR FIND A WAY HOW NOT TO REWRITE THE WHOLE LIST)

- make all action functions void
- create make_a_move function

- streamline sorting instructions immediately or when printing? 
	(--> printing sounds more doable)
- how to process the instructions in the best way?
	--> for large_stack testing multiple methods, so output only text
- how to optimize reversing the 3-item list (two ways) (maybe not necessary, as it 
	only matters when 6 elements) <-- THIS


- create fc "make_a_move" that will do the action and print the instruction 
	(params: action code (macro?) and stack indication) 
	array of function pointers & array of instructions with corresponding codes

small_stack

[- if 1 --> nothing]
- if 2 --> either nothing or swap
- if 3 --> sort_three
- if 4 --> move 1 to b (first one or lowest one?); sort_three, move 1 back to a
- if 5 --> move 2 to b (first two or lowest two?); sort_three, if needed swap 2, move back to a
- if 6 --> move 3 to b (first three or lowest?); sort_three on both stacks, merge
	(then again, if only 3 and 5 get tested...)


large_stack
- measure ways of tranches and choose the shortest one
- make sure B is always sorted

	1. x tranches; all < n / x * t
	2. each tranche (index * (n/x) [incl] -> (index + 1) * n/x [excl]
	3. measure total rotation necessary to get all of the elements,
		what kind of rotation (rr/r) and how many elements
		(shortest connecting path + distance from the start)
		all distances = n; n - largest distance = smallest connecting path
		top to elem1 + (n - dist[elem1, elem-1])



for optimization
- small stack: create program that runs all combinations of 5 numbers 
(and of 6 numbers), counts moves in each
	- then runs most costly scenarios, prints moves into a file, 
	identifies moves for optimization


