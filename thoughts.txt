to-do

- while pushing the last one to B, it stays on A
	A: 12308889 10000
	B: 788 104 94 14 70 41 17 1 -96 8 -29 3 -55
	pb
	A: 10000
	B: 12308889 788 104 94 14 70 41 17 1 -96 8 -29 3 -55
-->	pb <-- THIS ONE DIDN'T WORK
	A: 10000
	B: 12308889 788 104 94 14 70 41 17 1 -96 8 -29 3 -55
	A: 10000
	B: 12308889 788 104 94 14 70 41 17 1 -96 8 -29 3 -55

small_stack

[- if 1 --> nothing]
- if 2 --> either nothing or swap
- if 3 --> sort_three
- if 4 --> move 1 to b (first one or lowest one?); sort_three, move 1 back to a
- if 5 --> move 2 to b (first two or lowest two?); sort_three, if needed swap 2, move back to a
- if 6 --> move 3 to b (first three or lowest?); sort_three on both stacks, merge
	(then again, if only 3 and 5 get tested...)


large_stack
- measure ways of tranches and choose the shortest one
- make sure B is always sorted

	1. x tranches; all < n / x * t
	2. each tranche (index * (n/x) [incl] -> (index + 1) * n/x [excl]
	3. measure total rotation necessary to get all of the elements,
		what kind of rotation (rr/r) and how many elements
		(shortest connecting path + distance from the start)
		all distances = n; n - largest distance = smallest connecting path
		top to elem1 + (n - dist[elem1, elem-1])



for optimization
- small stack: create program that runs all combinations of 5 numbers 
(and of 6 numbers), counts moves in each
	- then runs most costly scenarios, prints moves into a file, 
	identifies moves for optimization


